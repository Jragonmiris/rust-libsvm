extern crate libc;

use ::datavec::DataVec;
use ::SvmNode;
use ::ffi::{CSvmProblem,svm_train, svm_check_parameter, svm_cross_validation};
use ::param::SvmParameter;
use ::model::SvmModel;
use std::ffi::{CStr};
use self::libc::{c_int};
use std::cell::RefCell;

/// This is a Rust wrapper over the C struct CSvmProblem. It represents training
/// data for generating an SVM model. It holds onto data passed in from Rust and 
/// constructs the C representation for libsvm.
pub struct SvmProblem {
    y: Vec<f64>,
    x: Vec<DataVec>,

    raw_y: RefCell<*mut f64>,
    raw_x: RefCell<Vec<*mut SvmNode>>,
}

impl SvmProblem {
    /// This constructs a new SVMProblem that can be passed into libsvm. It verifies that
    /// that the number of data vectors is equal to the number of labels, if this is not true
    /// it will return an error indicating the problem.
    ///
    /// All lifetimes and views into the data needed by C are managed by the library, and the user
    /// should not be able to cause libsvm to read or write after free with this library.
    pub fn new(mut x: Vec<DataVec>, mut y: Vec<f64>) -> Result<SvmProblem, String> {
        if x.len() != y.len() {
            return Err(format!("Mismatched number of vectors and labels. Vectors: {}, Labels: {}",
                               x.len(), y.len()));
        }

        let mut raw_x = Vec::with_capacity(x.len());

        for v in x.iter_mut() {
            v.resort();
            raw_x.push(v.as_mut_ptr())
        }

        Ok(SvmProblem {
        	raw_y: RefCell::new(y.as_mut_ptr()),
            y: y,
            x: x,
            raw_x: RefCell::new(raw_x),
        })
    }

    fn crep(&self) -> CSvmProblem {
    	CSvmProblem {
    		l: self.y.len() as i32,
    		y: *self.raw_y.borrow_mut(),
    		x: self.raw_x.borrow_mut().as_mut_ptr(),
    	}
    }

    /// Provides a read-only view into the feature vectors
    /// used to construct this problem.
    pub fn vectors(&self) -> &Vec<DataVec> {
        &self.x
    }

    /// Provides a read-only view into the training labels
    /// used to construct the problem.
    pub fn labels(&self) -> &Vec<f64> {
        &self.y
    }

    /// Equivalent to svm_check_paramter. It determines whether the given parameters
    /// are within the feasible range for the problem. This should be checked before cross_validation
    /// or train. 
    pub fn check_parameter(&self, param: &SvmParameter) -> Result<(), &str> {
        use std::str;
        use ::param::protected::crep;
        unsafe {
            let cstr_ptr = svm_check_parameter(&self.crep(), &crep(param));

            if cstr_ptr.is_null() {
                Ok(())
            } else {
                let cstr = CStr::from_ptr(cstr_ptr);
                Err(str::from_utf8(cstr.to_bytes()).unwrap())
            }
        }
    }

    /// Trains a model based on the parameters and problem.
    /// Since the trained model may reference memory from the parameters
    /// or problem, this takes ownership of both values. It's recommended you
    /// clone these values if you have need of them.
    pub fn train<'a>(self, param: SvmParameter) -> SvmModel<'a> {
        use ::model::model_from_c_rep;
        use ::param::protected::crep;
        unsafe {
        	model_from_c_rep(&mut (*svm_train(&self.crep(), &crep(&param))), self, param)
        }
    }

    /// Runs cross validation for nr_fold folds on the given parameters and problem.
    /// If labels is supplied, it will be filled with the labels generated by the cross validation,
    /// otherwise a new one will be allocated for you based on the number of problems in the
    /// training set. Either way, this vector is returned.
    pub fn cross_validation(&self,
                            param: &SvmParameter,
                            nr_fold: i32,
                            labels: Option<Vec<f64>>)
                            -> Vec<f64> {
        use ::param::protected::crep;
        let mut labels = match labels {
            None => {
                let mut labels = Vec::with_capacity(self.y.len());
                unsafe {
                    labels.set_len(self.y.len() as usize);
                }

                labels
            },
            Some(labels) => labels,
        };

        unsafe {
            svm_cross_validation(&self.crep(), &crep(param), nr_fold as c_int, labels.as_mut_ptr());
        }

        labels
    }
}

impl Clone for SvmProblem {
	fn clone(&self) -> SvmProblem {
		SvmProblem::new(self.x.clone(), self.y.clone()).unwrap()
	}
}